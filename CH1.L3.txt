Commands
Gator is a CLI application, and like many CLI applications, it has a set of valid commands. For example:

gator login - sets the current user in the config
gator register - adds a new user to the database
gator users - lists all the users in the database
etc.
We'll be hand-rolling our CLI rather than using a framework like Cobra or Bubble Tea. This will give us a better understanding of how CLI applications work.

Assignment
Let's start with a simple login command. For now, all it will do is set the current user in the config file. Usage:

gator login <username>

We want to add many commands to our CLI, so let's build a flexible system that will allow us to register new commands easily.

Before we can worry about command handlers, we need to think about how we will give our handlers access to the application state (later the database connection, but, for now, the config file). Create a state struct that holds a pointer to a config.
Create a `command` struct. A command contains a name and a slice of string arguments. For example, in the case of the login command, the name would be "login" and the handler will expect the arguments slice to contain one string, the username.
Create a login handler function: func handlerLogin(s *state, cmd command) error. This will be the function signature of all command handlers.
If the command's arg's slice is empty, return an error; the login handler expects a single argument, the username.
Use the state's access to the config struct to set the user to the given username. Remember to return any errors.
Print a message to the terminal that the user has been set.
Create a commands struct. This will hold all the commands the CLI can handle. Add a map[string]func(*state, command) error field to it. This will be a map of command names to their handler functions.
Implement the following methods on the commands struct:
func (c *commands) run(s *state, cmd command) error - This method runs a given command with the provided state if it exists.
func (c *commands) register(name string, f func(*state, command) error) - This method registers a new handler function for a command name.
In the main function, remove the manual update of the config file. Instead, simply read the config file, and store the config in a new instance of the state struct.
Create a new instance of the commands struct with an initialized map of handler functions.
Register a handler function for the login command.
Use os.Args to get the command-line arguments passed in by the user.
If there are fewer than 2 arguments, print an error message to the terminal and exit. Why two? The first argument is automatically the program name, which we ignore, and we require a command name.

You'll need to split the command-line arguments into the command name and the arguments slice to create a command instance. Use the commands.run method to run the given command and print any errors returned.
Test your CLI. Here are a few cases to consider:
go run . - Exit with code 1 and print an error that not enough arguments were provided.
go run . login - Exit with code 1 and print an error that a username is required.
go run . login alice - should set the current user in the config file to "alice" (and not overwrite the DB string)
Run and submit the CLI tests from the root of your project.
